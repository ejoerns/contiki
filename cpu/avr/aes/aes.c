#include <stddef.h>

#include "contiki.h"
#include "hal.h"

/* in case of AES not defined, compile dummy functions */
#ifndef AES
  #define AES 0
#endif

/* --------     AES>3 reserved     -------- */

/* -------- AES with HW RF231 CHIP -------- */
#if AES==3
  

  uint8_t aes_setKey(uint8_t key[]){
    if (hal_subregister_read(0x03, 7, 0)==0){					// check if RF231 is active
      return 1;									//  - chip not active -> return error
    }										//  - chip active ->
    uint8_t dummy[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};			// 
    hal_sram_fast(24, dummy, key);    						// issue command to chip
    return 0;									// return with no error
  }


  uint8_t aes_encode(uint8_t mode, uint8_t txt[], uint8_t ctxt[]){
    uint8_t status[1];								// check if aes unit is busy
    hal_sram_read(0x82, 1, status);						//   .
    switch (status[0]){								//   .
      case 129:									//   - chip aes unit in error state
        return 1;								//     - return error
      case 128:									//   - chip aes unit busy and in error state
        return 1;								//     - return error
      case 0:									//   - chip busy
        ;uint8_t retr = 3;							//     - set retry counter
        while (retr>0 && status[0]!=0){						//     - continue checking while busy and retry counter not 0
          hal_sram_read(0x82, 1, status);					//     - .
          retr--;        							//     - .
        }  									//     - either chip not busy anymore or retry counter 0 so run into case 1 (chip ready)
                      								//     - WARNING: code might break if aes unit stuck or too slow
      case 1:									//   - chip ready 
        switch (mode){								//     - determine mode
          case 1:								//       - CBC mode								
            hal_sram_fast(24, ctxt, txt);					//         - pass command to chip
            return 0;								//         - return with no error
          case 0:								//       - ECB mode
            hal_sram_fast( 8, ctxt, txt);					//         - pass command to chip
            return 0;								//         - return with no error
          default:								//       - unknown/reserved mode
            return 1;								//         - return error
        }									//
      default:									//   - unknown / undefined chip status
        return 2;								//     - return code error
    }										//
    return 2;    								// unreachable trap code (code safety) -> return code error
  }


  uint8_t aes_decode(uint8_t mode, uint8_t ctxt[], uint8_t txt[]){
    uint8_t status[1];								// check if aes unit is busy
    hal_sram_read(0x82, 1, status);						//   .
    switch (status[0]){								//   .
      case 129:									//   - chip aes unit in error state
        return 1;								//     - return error
      case 128:									//   - chip aes unit busy and in error state
        return 1;								//     - return error
      case 0:									//   - chip busy
        ;uint8_t retr=3;							//     - set retry counter
        while (retr>0 && status[0]!=0){						//     - continue checking while busy and retry counter not 0
          hal_sram_read(0x82, 1, status);					//     - .
          retr--;        							//     - .
        }        								//     - either chip not busy anymore or retry counter 0 so run into case 1 (chip ready)
										//     - WARNING: code might break if aes unit stuck or too slow
      case 1:									//   - chip ready 
        switch (mode){								//     - determine mode
          case 1:								//       - CBC mode
            hal_sram_fast(16, txt, ctxt);					//         - pass command to chip
            return 0;								//         - return with no error
          case 0:								//       - ECB mode
            hal_sram_fast( 0, txt, ctxt);					//         - pass command to chip
            return 0;								//         - return with no error
          default:								//       - unknown/reserved mode
            return 1;								//         - return error
        }									//
      default:									//   - unknown / undefined chip status
        return 2;								//     - return code error
    }										//
    return 2;    								// unreachable trap code (code safety) -> return code error
  }

#endif




/* --------  AES with Software AES -------- */
/* --------     fast SW AES CODE    ------- */
#if AES==2
  
  // fast multiplication lookuptable [1.5 kbyte]
  // NOTE: this is not a standard multiplication (see code below in slow variant)
  const uint8_t fmul[6][256]={{0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
                               0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
                               0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
                               0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
                               0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
                               0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
                               0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
                               0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
                               0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
                               0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
                               0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
                               0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
                               0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
                               0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
                               0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
                               0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5},

                              {0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
                               0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
                               0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
                               0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
                               0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
                               0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
                               0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
                               0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
                               0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
                               0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
                               0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
                               0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
                               0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
                               0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
                               0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
                               0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a},

                              {0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
                               0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
                               0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
                               0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
                               0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
                               0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
                               0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
                               0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
                               0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
                               0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
                               0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
                               0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
                               0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
                               0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
                               0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
                               0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46},

                              {0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
                               0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
                               0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
                               0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
                               0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
                               0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
                               0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
                               0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
                               0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
                               0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
                               0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
                               0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
                               0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
                               0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
                               0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
                               0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3}, 

                              {0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
                               0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
                               0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
                               0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
                               0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
                               0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
                               0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
                               0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
                               0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
                               0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
                               0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
                               0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
                               0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
                               0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
                               0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
                               0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97},
                              {0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
                               0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
                               0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
                               0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
                               0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
                               0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
                               0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
                               0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
                               0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
                               0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
                               0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
                               0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
                               0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
                               0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
                               0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
                               0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d}};

  /* multiplication help function */
  uint8_t mul(uint8_t a, uint8_t f){
    switch (f){									// determine factor
      case 0x01:								//   - factor 1
        return a;								//     - return value
      case 0x02:								//   - factor 2
        return fmul[0][a];							//     - return value
      case 0x03:								//   - factor 3
        return fmul[1][a];							//     - return value
      case 0x09:								//   - factor 3
        return fmul[2][a];							//     - return value
      case 0x0b:								//   - factor 11
        return fmul[3][a];							//     - return value
      case 0x0d: 								//   - factor 13
        return fmul[4][a];							//     - return value
      case 0x0e: 								//   - factor 14
        return fmul[5][a];							//     - return value
      default:									//   - other factor (not defined, break code on purpose)
        return 0;								//     - return 0
    }										//  
    return 0;									// unreachable trap code (code safety) -> return 0
  }

#endif




/* --------  AES with Software AES -------- */
/* --------     slow SW AES CODE    ------- */
#if AES==1

  /*
   * multiplication help function 
   * recursive calculation of special multiplication
   */
  uint8_t mul(uint8_t a, uint8_t f){
    uint8_t t2,t4;								// temporary variables
    switch (f){									// determine factor
      case 0x01:								//  - factor 1
        return a;								//    - return value
      case 0x02:								//  - factor 2
        return (a & 0x80) ? a << 1 ^ 27 : a << 1;				//    - return value
      case 0x03:								//  - factor 3
        return mul(a, 2) ^ a; 							//    - return value
      case 0x09:								//  - factor 9
        return mul(mul(mul(a, 2), 2), 2) ^ a;					//    - return value
      case 0x0b:								//  - factor 11
        t2 = mul(a, 2);								//    - intermediate result
        return mul(mul(t2, 2), 2) ^ t2 ^ a;					//    - return value
      case 0x0d:								//  - factor 13
        t4 = mul(mul(a, 2) , 2);						//    - intermediate result
        return mul(t4, 2) ^ t4 ^ a;						//    - return value
      case 0x0e: 								//  - factor 14
        t2 = mul(a, 2);								//    - intermediate result
        t4 = mul(t2, 2);							//    - intermediate result
        return mul(t4, 2) ^ t4 ^ t2;						//    - return value
      default:									//  - other factor (not defines, break code on purpose)
        return 0;								//    - return 0
    }										//
    return 0;									// unreachable trap code (code safety) -> return 0
  }


#endif




/* --------  AES with Software AES -------- */
/* --------    common SW AES CODE   ------- */
#if (AES==2) || (AES==1)

  // AES S-BOX
  const uint8_t sbox[256]={0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
                           0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
                           0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
                           0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
                           0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
                           0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
                           0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
                           0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
                           0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
                           0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
                           0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
                           0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
                           0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
                           0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
                           0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
                           0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};

  // AES inverse S-BOX
  const uint8_t isbox[256]={0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
                            0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
                            0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
                            0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
                            0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
                            0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
                            0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
                            0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
                            0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
                            0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
                            0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
                            0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
                            0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
                            0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
                            0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
                            0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d};

  // Values used in Rcon
  const uint8_t rc[10]={1,2,4,8,16,32,64,128,27,54};

  // Place to store the expanded key in (to save from recalculation every round)
  uint8_t expandedkey[176]= {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                             0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};

  // Storage for last clear text (for behaviorial purpose)
  uint8_t lastClearText[16] = {0, 0, 0, 0,
                               0, 0, 0, 0,
                               0, 0, 0, 0,
                               0, 0, 0, 0};

  // Storage for last cypher text (for behaviorial purpose)
  uint8_t lastCypherText[16]= {0, 0, 0, 0,
                               0, 0, 0, 0,
                               0, 0, 0, 0,
                               0, 0, 0, 0};

  /**
   * Array copy helpfunction
   * Copys array b into array a
   * !! Possible speedup via pointer operation
   */
  void copyArray(uint8_t a[], uint8_t b[]){
    a[ 0]=b[ 0]; a[ 1]=b[ 1]; a[ 2]=b[ 2]; a[ 3]=b[ 3];
    a[ 4]=b[ 4]; a[ 5]=b[ 5]; a[ 6]=b[ 6]; a[ 7]=b[ 7];
    a[ 8]=b[ 8]; a[ 9]=b[ 9]; a[10]=b[10]; a[11]=b[11];
    a[12]=b[12]; a[13]=b[13]; a[14]=b[14]; a[15]=b[15];
    return;
  }

  /**
   * SubBytes helpfuncton
   * Substitutes all 16 bytes of a via S-BOX
   *
   * [CODE]
   *   SubBytes(a);
   *   iSubBytes(a);
   * [/CODE]
   * -> identity
   */
  void SubBytes(uint8_t a[]){
    a[ 0] = sbox[a[ 0]]; a[ 1]=sbox[a[ 1]]; a[ 2]=sbox[a[ 2]]; a[ 3]=sbox[a[ 3]];
    a[ 4] = sbox[a[ 4]]; a[ 5]=sbox[a[ 5]]; a[ 6]=sbox[a[ 6]]; a[ 7]=sbox[a[ 7]];
    a[ 8] = sbox[a[ 8]]; a[ 9]=sbox[a[ 9]]; a[10]=sbox[a[10]]; a[11]=sbox[a[11]];
    a[12] = sbox[a[12]]; a[13]=sbox[a[13]]; a[14]=sbox[a[14]]; a[15]=sbox[a[15]];
    return;
  }

  /**
   * iSubBytes helpfunction
   * Substitutes all 16 bytes of a via inverse S-BOX
   *
   * [CODE]
   *   iSubBytes(a);
   *   SubBytes(a);
   * [/CODE]
   * -> identity
   */
  void iSubBytes(uint8_t a[]){
    a[ 0]=isbox[a[ 0]]; a[ 1]=isbox[a[ 1]]; a[ 2]=isbox[a[ 2]]; a[ 3]=isbox[a[ 3]];
    a[ 4]=isbox[a[ 4]]; a[ 5]=isbox[a[ 5]]; a[ 6]=isbox[a[ 6]]; a[ 7]=isbox[a[ 7]];
    a[ 8]=isbox[a[ 8]]; a[ 9]=isbox[a[ 9]]; a[10]=isbox[a[10]]; a[11]=isbox[a[11]];
    a[12]=isbox[a[12]]; a[13]=isbox[a[13]]; a[14]=isbox[a[14]]; a[15]=isbox[a[15]];
    return;
  }

  /**
   * ShiftRows helpfunction
   *
   * Shifts bytes of a like so:
   *
   *     / a[ 0]  a[ 4]  a[ 8]  a[12] \          / a[ 0]  a[ 4]  a[ 8]  a[12] \
   *    /  a[ 1]  a[ 5]  a[ 9]  a[13]  \        /  a[ 5]  a[ 9]  a[13]  a[ 1]  \
   * a= \  a[ 2]  a[ 6]  a[10]  a[14]  / => a'= \  a[10]  a[14]  a[ 2]  a[ 6]  /
   *     \ a[ 3]  a[ 7]  a[11]  a[15] /          \ a[15]  a[ 3]  a[ 7]  a[11] /
   *
   *
   * [CODE]
   *   ShiftRows(a);
   *   iShiftRows(a);
   * [/CODE]
   * -> identity
   */
  void ShiftRows(uint8_t a[]){
    uint8_t temp=a[1]; a[1]=a[5]; a[5]=a[9]; a[9]=a[13]; a[13]=temp;
    temp=a[2]; a[2]=a[10]; a[10]=temp; temp=a[6]; a[6]=a[14]; a[14]=temp;
    temp=a[3]; a[3]=a[15]; a[15]=a[11]; a[11]=a[7]; a[7]=temp;
    return;
  }

  
  /**
   * iShiftRows helpfunction
   *
   * Shifts bytes of a like so:
   *
   *     / a[ 0]  a[ 4]  a[ 8]  a[12] \          / a[ 0]  a[ 4]  a[ 8]  a[12] \
   *    /  a[ 1]  a[ 5]  a[ 9]  a[13]  \        /  a[13]  a[ 1]  a[ 5]  a[ 9]  \
   * a= \  a[ 2]  a[ 6]  a[10]  a[14]  / => a'= \  a[10]  a[14]  a[ 2]  a[ 6]  /
   *     \ a[ 3]  a[ 7]  a[11]  a[15] /          \ a[ 7]  a[11]  a[15]  a[ 3] /
   *
   *
   * [CODE]
   *   iShiftRows(a);
   *   ShiftRows(a);
   * [/CODE]
   * -> identity
   */
  void iShiftRows(uint8_t a[]){
    uint8_t temp=a[1]; a[1]=a[13]; a[13]=a[9]; a[9]=a[5]; a[5]=temp; 
    temp=a[2]; a[2]=a[10]; a[10]=temp; temp=a[6]; a[6]=a[14]; a[14]=temp;
    temp=a[3]; a[3]=a[7]; a[7]=a[11]; a[11]=a[15]; a[15]=temp;
    return;
  }

  /**
   * MixColumns helpfunction
   * Computes complex AES MixColumns operation
   */
  void MixColumns(uint8_t a[]){
    uint8_t t[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    uint8_t i=0;
    while(i<4){
      t[4*i+0]=mul(a[4*i+0], 2) ^ mul(a[4*i+1], 3)^ mul(a[4*i+2], 1)^ mul(a[4*i+3], 1);
      t[4*i+1]=mul(a[4*i+0], 1) ^ mul(a[4*i+1], 2)^ mul(a[4*i+2], 3)^ mul(a[4*i+3], 1);
      t[4*i+2]=mul(a[4*i+0], 1) ^ mul(a[4*i+1], 1)^ mul(a[4*i+2], 2)^ mul(a[4*i+3], 3);
      t[4*i+3]=mul(a[4*i+0], 3) ^ mul(a[4*i+1], 1)^ mul(a[4*i+2], 1)^ mul(a[4*i+3], 2);
      i++;
    }
    copyArray(a, t);
    return;
  }

  /**
   * iMixColumns helpfunction
   * Computes complex AES inverse MixColumns operation
   */
  void iMixColumns(uint8_t a[]){
    uint8_t t[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    uint8_t i=0;
    while(i<4){
      t[4*i+0]=mul(a[4*i+0], 0x0e) ^ mul(a[4*i+1], 0x0b) ^ mul(a[4*i+2], 0x0d) ^ mul(a[4*i+3], 0x09);
      t[4*i+1]=mul(a[4*i+0], 0x09) ^ mul(a[4*i+1], 0x0e) ^ mul(a[4*i+2], 0x0b) ^ mul(a[4*i+3], 0x0d);
      t[4*i+2]=mul(a[4*i+0], 0x0d) ^ mul(a[4*i+1], 0x09) ^ mul(a[4*i+2], 0x0e) ^ mul(a[4*i+3], 0x0b);
      t[4*i+3]=mul(a[4*i+0], 0x0b) ^ mul(a[4*i+1], 0x0d) ^ mul(a[4*i+2], 0x09) ^ mul(a[4*i+3], 0x0e);
      i++;
    }
    copyArray(a, t);
    return;
  }

  /**
   * AddRoundKey helpfunction
   * Adds (XORs) the roundkey (#=round) of keyarray (key) to (a)
   */
  void AddRoundKey(uint8_t a[], uint8_t key[], uint8_t round){
    uint8_t i=0;
    while(i<16){
      a[i]=a[i] ^ key[round*16+i];
      i++;
    }
    return;
  }

  /**
   * SubWord helpfunction
   * Substitutes a word (4 byte) of a via S-BOX
   */
  void SubWord(uint8_t a[]){
    a[0]=sbox[a[0]];
    a[1]=sbox[a[1]];
    a[2]=sbox[a[2]];
    a[3]=sbox[a[3]];
    return;
  }

  /**
   * RotWord helpfunction
   * Rotates vector a (4 byte) like a=(a[0], a[1], a[2], a[3]) -> a'=(a[1], a[2], a[3], a[0])
   */
  void RotWord(uint8_t a[]){
    uint8_t t=a[0];
    a[0]=a[1];
    a[1]=a[2];
    a[2]=a[3];
    a[3]=t;
    return; 
  }

  /**
   * XOR helpfunction
   * XORs vector b (4 byte) onto a (4 byte)
   */
  void XOR(uint8_t a[], uint8_t b[]){
    a[0]=a[0]^b[0];
    a[1]=a[1]^b[1];
    a[2]=a[2]^b[2];
    a[3]=a[3]^b[3];
    return;
  }

  /**
   * Rcon helpfunction
   * Creates Rcon vector of (x) round in (y)
   */
  void Rcon(uint8_t x, uint8_t y[]){
    y[0]=rc[x-1];
    y[1]=0;
    y[2]=0;
    y[3]=0;
    return;
  }

/* --------   end of helpfunctions  ------- */
/* ---------------------------------------- */
/* --------    common SW AES CODE   ------- */


  uint8_t aes_setKey(uint8_t key[]){
    copyArray(expandedkey, key);										// copy handed key into expanded keyarray							
    uint8_t i=4;												// perform key expansion
    while(i<44){												//   .
      uint8_t w[4]={expandedkey[4*(i-1)],expandedkey[4*(i-1)+1],expandedkey[4*(i-1)+2],expandedkey[4*(i-1)+3]};	//   .
      if (i%4==0){												//   .
        RotWord(w);												//   .
        SubWord(w);												//   .
        uint8_t t[4]={0,0,0,0};											//   .
        Rcon(i>>2,t);											        //   .
        XOR(w, t);												//   .
      }														//   .
      uint8_t temp[4]={expandedkey[4*(i-4)],									//   .
                       expandedkey[4*(i-4)+1],									//   .
                       expandedkey[4*(i-4)+2],									//   .
                       expandedkey[4*(i-4)+3]};									//   .
      XOR(w,temp);												//   .
      expandedkey[4*i]=w[0];											//   .
      expandedkey[4*i+1]=w[1];											//   .
      expandedkey[4*i+2]=w[2];											//   .
      expandedkey[4*i+3]=w[3];											//   .
      i++;													//   .
    }														//   .
    return 0;													// return with no error
  }


  uint8_t aes_encode(uint8_t mode, uint8_t txt[], uint8_t ctxt[]){
    switch (mode){								// determine mode
      case 1:									//   - CBC mode
        XOR(txt, lastCypherText);						//     - XOR last cyphertext onto text
										//     - encode result via ECB mode
      case 0:									//   - ECB mode
        copyArray (ctxt, lastCypherText);					//     - set result of last round into returnarray
										//
        copyArray (lastCypherText, txt);					//     - copy text into last cyphertext and compute on that : 
        AddRoundKey(lastCypherText, expandedkey, 0);				//       - AddRoundkey (round 0)
        uint8_t round=1;							//       - round counter
        while(round<10){							//       - each round do :
          SubBytes(lastCypherText);						//         - SubBytes
          ShiftRows(lastCypherText);						//	   - ShiftRows
          MixColumns(lastCypherText);						//	   - MixColumns
          AddRoundKey(lastCypherText, expandedkey, round);			//         - AddRoundKey
          round++;								//         - next round
        }									//       - last round
        SubBytes(lastCypherText);						//	 - SubBytes
        ShiftRows(lastCypherText);						//	 - ShiftRows
        AddRoundKey(lastCypherText, expandedkey, 10);				//	 - AddRoundKey (round 10)
        return 0;								//	 - return with no error
      default:									//   - undefined/reserved mode
        return 2;								//     - return with codeerror
    }										//
    return 2;									// unreachable trap code (code safety) -> return code error
  }


  uint8_t aes_decode(uint8_t mode, uint8_t ctxt[], uint8_t txt[]){
    switch (mode){								// determine mode
      case 0:									//   - ECB mode
        copyArray (txt, lastClearText);						//     - set result of last round into returnarray
										//
        copyArray (lastClearText, ctxt);					//     - copy cryptotext into last cleartext
        AddRoundKey(lastClearText, expandedkey, 10);				//     - AddRoundKey (round 10)
        uint8_t round=9;							//     - round counter
        while(round>0){								//     - each round do :
          iShiftRows(lastClearText);						//       - inverse ShiftRows
          iSubBytes(lastClearText);						//       - inverse SubBytes
          AddRoundKey(lastClearText, expandedkey, round);			//       - AddRoundKey
          iMixColumns(lastClearText);						//       - inverse MixColumns
          round--;								//       - next round
        }									//     - last round
        iShiftRows(lastClearText);						//     - inverse ShiftRows
        iSubBytes(lastClearText);						//     - inverse SubBytes
        AddRoundKey(lastClearText, expandedkey, 0);				//     - AddRoundKey (round 0)
        return 0;								//     - return with no error
      case 1:									//   - CBC mode
        aes_decode(0, ctxt, txt);						//     - decode using ECB
        XOR(txt, lastCypherText);						//     - XOR last cyphertext onto text
        copyArray(lastCypherText, ctxt);					//     - copy cyphertext into last cyphertext
      default:									//   - undefined/reserved mode
        return 2;								//     - return with codeerror
    }										//
    return 2;									// unreachable trap code (code safety) -> return code error
  }

#endif




/* --------         no AES         -------- */
/* --------   dummy functions only  ------- */
#if AES==0

  uint8_t aes_setKey(uint8_t key){
    return 2;									// return code error
  }

  uint8_t aes_encode(uint8_t mode, uint8_t txt[], uint8_t ctxt[]){
    return 2;									// return code error
  }

  uint8_t aes_decode(uint8_t mode, uint8_t ctxt[], uint8_t txt[]){
    return 2;									// return code error
  }

#endif

/* --------  common functionality  -------- */
  /**
   * Function to determine the AES type in use at runtime
   *
   * return 3 if RF-231 AES
   *        2 if fast SW AES
   *        1 if slow SW AES
   *        0 if no AES
   */
  uint8_t aesVer(){
    return AES;
  }